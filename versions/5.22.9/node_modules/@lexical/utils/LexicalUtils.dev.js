/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';

var lexical = require('lexical');

/** @module @lexical/utils */
function addClassNamesToElement(element, ...classNames) {
  classNames.forEach(className => {
    if (typeof className === 'string') {
      element.classList.add(...className.split(' '));
    }
  });
}
function removeClassNamesFromElement(element, ...classNames) {
  classNames.forEach(className => {
    if (typeof className === 'string') {
      element.classList.remove(...className.split(' '));
    }
  });
}
function $dfs(startingNode, endingNode) {
  const nodes = [];
  const start = (startingNode || lexical.$getRoot()).getLatest();
  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);
  let node = start;
  let depth = $getDepth(node);

  while (node !== null && !node.is(end)) {
    nodes.push({
      depth,
      node
    });

    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {
      node = node.getFirstChild();
      depth++;
    } else {
      // Find immediate sibling or nearest parent sibling
      let sibling = null;

      while (sibling === null && node !== null) {
        sibling = node.getNextSibling();

        if (sibling === null) {
          node = node.getParent();
          depth--;
        } else {
          node = sibling;
        }
      }
    }
  }

  if (node !== null && node.is(end)) {
    nodes.push({
      depth,
      node
    });
  }

  return nodes;
}

function $getDepth(node) {
  let innerNode = node;
  let depth = 0;

  while ((innerNode = innerNode.getParent()) !== null) {
    depth++;
  }

  return depth;
}

function $getNearestNodeOfType(node, klass) {
  let parent = node;

  while (parent != null) {
    if (parent instanceof klass) {
      return parent;
    }

    parent = parent.getParent();
  }

  return null;
}
function $getNearestBlockElementAncestorOrThrow(startNode) {
  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());

  if (!lexical.$isElementNode(blockNode)) {
    {
      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
    }
  }

  return blockNode;
}
function $findMatchingParent(startingNode, findFn) {
  let curr = startingNode;

  while (curr !== lexical.$getRoot() && curr != null) {
    if (findFn(curr)) {
      return curr;
    }

    curr = curr.getParent();
  }

  return null;
}
function mergeRegister(...func) {
  return () => {
    func.forEach(f => f());
  };
}
function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
  const $isTargetNode = node => {
    return node instanceof targetNode;
  };

  const $findMatch = node => {
    // First validate we don't have any children that are of the target,
    // as we need to handle them first.
    const children = node.getChildren();

    for (let i = 0; i < children.length; i++) {
      const child = children[i];

      if ($isTargetNode(child)) {
        return null;
      }
    }

    let parentNode = node;
    let childNode = node;

    while (parentNode !== null) {
      childNode = parentNode;
      parentNode = parentNode.getParent();

      if ($isTargetNode(parentNode)) {
        return {
          child: childNode,
          parent: parentNode
        };
      }
    }

    return null;
  };

  const elementNodeTransform = node => {
    const match = $findMatch(node);

    if (match !== null) {
      const {
        child,
        parent
      } = match; // Simple path, we can move child out and siblings into a new parent.

      if (child.is(node)) {
        handleOverlap(parent, node);
        const nextSiblings = child.getNextSiblings();
        const nextSiblingsLength = nextSiblings.length;
        parent.insertAfter(child);

        if (nextSiblingsLength !== 0) {
          const newParent = cloneNode(parent);
          child.insertAfter(newParent);

          for (let i = 0; i < nextSiblingsLength; i++) {
            newParent.append(nextSiblings[i]);
          }
        }

        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
          parent.remove();
        }
      }
    }
  };

  return editor.registerNodeTransform(targetNode, elementNodeTransform);
} // eslint-disable-next-line @typescript-eslint/no-explicit-any

function unstable_internalCreateNodeFromParse(parsedNode, parsedNodeMap, editor, parentKey, activeEditorState) {
  const nodeType = parsedNode.__type;

  const registeredNode = editor._nodes.get(nodeType);

  if (registeredNode === undefined) {
    {
      throw Error(`createNodeFromParse: type "${nodeType}" + not found`);
    }
  } // Check for properties that are editors


  for (const property in parsedNode) {
    const value = parsedNode[property];

    if (value != null && typeof value === 'object') {
      const parsedEditorState = value.editorState;

      if (parsedEditorState != null) {
        const nestedEditor = lexical.createEditor({
          namespace: parsedEditorState.namespace
        });
        nestedEditor._nodes = editor._nodes;
        nestedEditor._parentEditor = editor._parentEditor;
        nestedEditor._pendingEditorState = unstable_convertLegacyJSONEditorState(nestedEditor, parsedEditorState);
        parsedNode[property] = nestedEditor;
      }
    }
  }

  const NodeKlass = registeredNode.klass;
  const parsedKey = parsedNode.__key; // We set the parsedKey to undefined before calling clone() so that
  // we get a new random key assigned.

  parsedNode.__key = undefined;
  const node = NodeKlass.clone(parsedNode);
  parsedNode.__key = parsedKey;
  const key = node.__key;

  activeEditorState._nodeMap.set(key, node);

  node.__parent = parentKey; // We will need to recursively handle the children in the case
  // of a ElementNode.

  if (lexical.$isElementNode(node)) {
    const children = parsedNode.__children;

    for (let i = 0; i < children.length; i++) {
      const childKey = children[i];
      const parsedChild = parsedNodeMap.get(childKey);

      if (parsedChild !== undefined) {
        const child = unstable_internalCreateNodeFromParse(parsedChild, parsedNodeMap, editor, key, activeEditorState);
        const newChildKey = child.__key;

        node.__children.push(newChildKey);
      }
    }

    node.__indent = parsedNode.__indent;
    node.__format = parsedNode.__format;
    node.__dir = parsedNode.__dir;
  } else if (lexical.$isTextNode(node)) {
    node.__format = parsedNode.__format;
    node.__style = parsedNode.__style;
    node.__mode = parsedNode.__mode;
    node.__detail = parsedNode.__detail;
  }

  return node;
}

function unstable_parseEditorState(parsedEditorState, editor) {
  // This is hacky, do not do this!
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const EditorStateClass = editor._editorState.constructor;
  const nodeMap = new Map();
  const editorState = new EditorStateClass(nodeMap);
  const parsedNodeMap = new Map(parsedEditorState._nodeMap); // root always exists in Map

  const parsedRoot = parsedNodeMap.get('root');
  const isUpdating = editor._updating;

  try {
    editor._updating = false;
    editor.update(() => {
      const dirtyElements = editor._dirtyElements;
      const dirtyLeaves = editor._dirtyLeaves;
      const dirtyType = editor._dirtyType;
      editor._dirtyElements = new Map();
      editor._dirtyLeaves = new Set();
      editor._dirtyType = 0;

      try {
        unstable_internalCreateNodeFromParse(parsedRoot, parsedNodeMap, editor, null, editorState);
      } finally {
        editor._dirtyElements = dirtyElements;
        editor._dirtyLeaves = dirtyLeaves;
        editor._dirtyType = dirtyType;
      }
    });
  } finally {
    editor._updating = isUpdating;
  }

  editorState._readOnly = true;
  return editorState;
} // TODO: remove this function in version 0.4


function unstable_convertLegacyJSONEditorState(editor, maybeStringifiedEditorState) {
  const parsedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
  return unstable_parseEditorState(parsedEditorState, editor);
}
function $restoreEditorState(editor, editorState) {
  const FULL_RECONCILE = 2;
  const nodeMap = new Map(editorState._nodeMap);
  const activeEditorState = editor._pendingEditorState;

  if (activeEditorState) {
    activeEditorState._nodeMap = nodeMap;
  }

  editor._dirtyType = FULL_RECONCILE;
  const selection = editorState._selection;
  lexical.$setSelection(selection === null ? null : selection.clone());
}
function $insertNodeToNearestRoot(node) {
  const selection = lexical.$getSelection();

  if (lexical.$isRangeSelection(selection)) {
    const focusNode = selection.focus.getNode();
    focusNode.getTopLevelElementOrThrow().insertAfter(node);
  } else if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {
    const nodes = selection.getNodes();
    nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);
  } else {
    const root = lexical.$getRoot();
    root.append(node);
  }

  const paragraphNode = lexical.$createParagraphNode();
  node.insertAfter(paragraphNode);
  paragraphNode.select();
  return node.getLatest();
}
function $wrapNodeInElement(node, createElementNode) {
  const elementNode = createElementNode();
  node.replace(elementNode);
  elementNode.append(node);
  return elementNode;
}

exports.$dfs = $dfs;
exports.$findMatchingParent = $findMatchingParent;
exports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;
exports.$getNearestNodeOfType = $getNearestNodeOfType;
exports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;
exports.$restoreEditorState = $restoreEditorState;
exports.$wrapNodeInElement = $wrapNodeInElement;
exports.addClassNamesToElement = addClassNamesToElement;
exports.mergeRegister = mergeRegister;
exports.registerNestedElementResolver = registerNestedElementResolver;
exports.removeClassNamesFromElement = removeClassNamesFromElement;
exports.unstable_convertLegacyJSONEditorState = unstable_convertLegacyJSONEditorState;
